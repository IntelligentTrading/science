from evaluation import Evaluation
from orders import OrderType
import logging
from data_sources import get_price, get_filtered_signals, NoPriceDataException


class SignalDrivenBacktester(Evaluation):

    def __init__(self, strategy, transaction_currency, counter_currency,
                 start_cash, start_crypto, start_time, end_time, source=0,
                 resample_period=60, evaluate_profit_on_last_order=False, verbose=True, time_delay=0):
        super().__init__(strategy, transaction_currency, counter_currency,
                 start_cash, start_crypto, start_time, end_time, source,
                 resample_period, evaluate_profit_on_last_order, verbose)
        self.signals = get_filtered_signals(start_time=start_time, end_time=end_time, counter_currency=counter_currency,
                                            transaction_currency=transaction_currency,
                                            source=source)
        self._start_crypto_currency = self._transaction_currency
        self._buy_currency = self._transaction_currency
        self.orders, self.order_signals = self._strategy.get_orders(
            signals = self.signals,
            start_cash=self._start_cash,
            start_crypto=self._start_crypto,
            time_delay=0)
        self.run()


    def fill_trading_df(self, orders):
        for i, order in enumerate(orders):
            if i == 0: # first order
                assert order.order_type == OrderType.BUY and order.transaction_currency == self._start_crypto_currency

            if order.order_type == OrderType.BUY:
                self._buy_currency = order.transaction_currency
            elif order.order_type == OrderType.SELL:
                assert order.transaction_currency == self._buy_currency
            self.execute_order(order)
            self._current_timestamp = order.timestamp
            self._current_price = order.unit_price
            self._current_order = order
            self._current_signal = self.order_signals[i]
            self._write_to_trading_df()
        self._end_crypto_currency = self._buy_currency
        self._finalize_backtesting()


    def execute_orders(self, orders):
        for i, order in enumerate(orders):
            if i == 0: # first order
                assert order.order_type == OrderType.BUY
            self.execute_order(order)

        if self._evaluate_profit_on_last_order and self.num_trades > 0:
            end_price = orders[-1].unit_price
        else:
            if self.num_trades == 0:
                logging.warning("No orders were generated by the chosen strategy.")
            try:
                if self.num_trades > 0:
                    end_price = get_price(self._buy_currency, self._end_time, self._source, self._counter_currency)
                    if orders[-1].order_type == OrderType.BUY:
                        delta_cash = self._cash + end_price * self._crypto
                        if delta_cash > self.invested_on_buy:
                            self.num_profitable_trades += 1
                            buy_sell_pair_profit_percent = (delta_cash - self.invested_on_buy) / self.invested_on_buy * 100
                            self.avg_profit_per_trade_pair += buy_sell_pair_profit_percent
                else:
                    end_price = get_price(self.start_crypto_currency, self._end_time, self._source, self._counter_currency)

            except NoPriceDataException:
                logging.error("No price data found")
                end_price = None

        if self.num_sells != 0:
            self.avg_profit_per_trade_pair /= self.num_sells

        self._end_crypto_currency = self._buy_currency if self.num_trades > 0 else self._transaction_currency

        self._finalize_backtesting()

    def run(self):
        self.fill_trading_df(self.orders)
        #self.execute_orders(self.orders)